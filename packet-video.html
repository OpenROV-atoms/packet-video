<link rel="import" href="../polymer/polymer.html">
<dom-module id="packet-video">
  <style>
    /* TODO(polyup): For speed, consider reworking these styles with .classes
                     and #ids rather than [attributes].
    */

    [hidden] {
      display: none !important;
    }
    /* make the video stretch to fill the screen in WebKit */

    :-webkit-full-screen {
      width: 100%;
      height: 100%;
    }
  </style>
  <style>
    :host {
      display: block;
      width: 320px;
      height: 200px
    }

    #video {
      width: 100%;
      height: 100%;
    }

    #stats {
      top: 5px;
      left: 5px;
      position: absolute;
      padding: 2px;
      margin: 10px;
      font-variant: bold;
      color: orange;
      font-size: 1.5vw;
    }
  </style>
  <template>
    <div id="videocontainer" style="display:block; height:100%; width:100%; position:relative;" on-hover="">
      <img id="videomissing" src="{{novideoImageURL}}" hidden$="{{isHidden}}">
      <video id="video" ></video>
      <content></content>
      <div id='stats' hidden$="{{showStats}}">
        <div id='fps'><span>{{fps}}</span> decoded fps</div>
        <div id='bps'><span>{{bps}}</span> b/s</div>
        <div id='currentTime'><span>{{currentTime}}</span> (current time)</div>
        <div id='buffertime'><span>{{formatSeconds(buffertime)}}</span> (buffertime)</div>
        <div><span>{{formatSeconds(buffertimeStart)}}</span> (buffertime-start)</div>
        <div><span>{{formatSeconds(buffertimeEnd)}}</span> (buffertime-end)</div>

        <div id='gaptime'><span>{{formatSeconds(gaptime)}}</span> (gaptime)</div>
        <div id='queue'><span>{{queueSize}}</span> (queue size)</span>
        </div>
        <div><span>{{error}}</span> Video error?</div>
        <div><span>{{paused}}</span> Video paused?</div>
        <div><span>{{videoState}}</span> Video state</div>
        <div><span>{{droppedframes}}</span> dropped frames</div>
        <div><span>{{decodedframes}}</span> decoded frames</div>
        <div><span>{{stats.errors.video.code3}}</span> code3 video errors</div>
        <div><span>{{stats.errors.video.bufferDisassociation}}</span> buffer dissasociations</div>
        <div><span>{{stats.errors.video.totalfailure}}</span> totalfailure</div>
      </div>
    </div>
  </template>
  <script src="../visionmedia-debug/dist/debug.js"></script>
  <script>
    (function() {
      var log = debug('socket-video:unclassified');
      var log_setup = debug('socket-video:setup');
      var log_trace = debug('socket-video:trace');
      var log_healthCheck = debug('socket-video:healthCheck');
      Polymer({
        is: 'packet-video',
        properties: {
          latencyReducer: {
            type: Boolean,
            value: true
          },
          initialized: {
            type: Boolean,
            value: false,
            readOnly: true
          },
          showStats: {
            type: Boolean,
            value: false
          }
        },
        ready: function(){
          var self = this;
          this.fps_count = 0;
          this.fps = 0;
          this.datapackets_count = 0;
          this.bytes_count = 0;
          this.bps = 0;
          this.buffertime = 0;
          this.buffertimeStart = 0;
          this.buffertimeEnd = 0;
          this.gaptime = 0;
          this.paused = true;
          this.error = false;
          this.currentTime = 0;
          this.droppedframes = 0;
          this.decodedframes = 0;
          this.stats = {
            errors: {
              video: {
                code3: 0,
                bufferDisassociation: 0,
                totalfailure: 0
              },
              mediaSource: 0,
              bufferSource: 0
            }
          };
          var video = this.$.video;
          if (this.latencyReducer) {
            this.latencyIntervalTimer = setInterval(function(){
              if(video.paused){return;}
              if ((video.seekable.end(0) - video.currentTime) > .2){
                video.currentTime = video.seekable.end(0) - 0.001;
              }
            },500);
          }


          this.statsIntervalTimer = setInterval(function () {
            if (!self.initialized){
              return;
            }
            var video = self.$.video;
            self.paused = video.paused;
            self.queueSize = self.buffer.length;
            self.error = video.error !== null;
            self.currentTime = video.currentTime.toLocaleString();
            self.buffertime = video.buffered.end(0) - video.buffered.start(0);
            self.gaptime = video.buffered.end(0) - video.currentTime;
            self.buffertimeStart = video.buffered.start(0);
            self.buffertimeEnd = video.seekable.end(0);
            self.droppedframes = video.webkitDroppedFrameCount;
            self.decodedframes = video.webkitDecodedFrameCount || video.mozDecodedFrames;
            self.fps = self.droppedframes + self.decodedframes - self.fps_count;
            self.fps = self.fps*2; //per second
            self.bps = (self.bytes_count * 8).toLocaleString();
            self.bps = self.bps*2;
            self.fps_count = self.droppedframes + self.decodedframes;
            self.bytes_count = 0;
          },500);

          this.formatSeconds= function (seconds) {
            return Number(seconds).toFixed(2) + ' seconds';
          };
        },
        buffer: [],
        initInProgress: false,
        init: function(initFrame, callback) {
          if (this.initInProgress) {return};
          this.initInProgress=true;
          var buffer=this.buffer;
          buffer.push(initFrame)
          var video = this.$.video;
          [
            'loadstart',
            'emptied',
            'canplaythrough',
            'ended',
            'ratechange',
            'progress',
            'stalled',
            'playing',
            'durationchange',
            'resize',
            'suspend',
            'loadedmetadata',
            'waiting',
            'timeupdate',
            'volumechange',
            'abort',
            'loadeddata',
            'seeking',
            'play',
            'error',
            'canplay',
            'seeked',
            'pause'
          ].forEach(function (ev) {
            video.addEventListener(ev, function () {
              log_trace('video event:', ev);
            });
          });

          // ./mp4info frag_bunny.mp4 | grep Codec
          var mimeCodec = 'video/mp4; codecs="avc1.4d401e"';

          var mediaSource = null;
          if ('MediaSource' in window && MediaSource.isTypeSupported(mimeCodec)) {
            mediaSource = new MediaSource;
            [
              'sourceopen',
              'sourceended',
              'sourceclose',
              'loadedmetadata',
              'loadeddata',
              'canplay',
              'canplaythrough',
              'seeking',
              'ended',
              'loadstart',
              'playing',
              'waiting',
              'progress',
              'suspend',
              'stalled'
            ].forEach(function (ev) {
              mediaSource.addEventListener(ev, function () {
                log_trace('mediaSource event:', ev);
              });
            });
            var videoRequiresHumanTouch=/Android/i.test(navigator.userAgent);
            var safePlay = function(){
              if (!video.paused){
                return;
              }
              if (videoRequiresHumanTouch){
                videoRequiresHumanTouch = false;
                document.addEventListener("touchstart", function(e){
                   video.play();
                   document.removeEventListener(e.type, arguments.callee);
                 }, false);
              } else {
                video.play();
              }
            }
            video.safePlay = safePlay;

            video.addEventListener('suspend',function(){
              //on a mobile connection, this seems to get triggered
              setTimeout(function(){
                safePlay()
              },1000);
            });

             [
               'addsourcebuffer',
               'removesourcebuffer'
             ].forEach(function (ev) {
                mediaSource.sourceBuffers.addEventListener(ev, function () {
                 log_trace('sourceBufferList event:', ev);
               });
             });

            var self=this;
            mediaSource.sourceBuffers.addEventListener('addsourcebuffer', function(){
              self._setInitialized(true);
              callback();
              self.initInProgress=false;
            })


            //console.log(mediaSource.readyState); // closed
            video.src = URL.createObjectURL(mediaSource);

            mediaSource.addEventListener('sourceopen', sourceOpen);
          } else {
            console.error('Unsupported MIME type or codec: ', mimeCodec);
            return;
          }



          var sourceBuffer = null;

          function sourceOpen(_) {
             sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);
             [
               'updatestart',
               'updateend',
               'update',
               'error',
               'abort'
             ].forEach(function (ev) {
               sourceBuffer.addEventListener(ev, function () {
                 //TODO: Move the event tracing to a debug library for runtime on/off
                 log_trace('sourceBuffer event:', ev);
               });
             });
             if (sourceBuffer.mode){
                sourceBuffer.mode = 'sequence';
             }
             log_trace('sourceBuffer mode:',sourceBuffer.mode);
             sourceBuffer.addEventListener('updateend',function(){
               checkBuffer;
             })

             video.addEventListener('timeupdate', checkBuffer);

             video.addEventListener('canplay', function() {
                safePlay();
             });
             video.addEventListener('loadedmetadata',function(){
               setTimeout(function(){
                 //video.currentTime+=.001;
                 video.safePlay();
               },500);
               //video.play(); //because canplay won't fire
             });
            //http://code.tutsplus.com/tutorials/html5-audio-and-video-what-you-must-know--net-15545
            video.addEventListener('loadeddata',function(){
              setTimeout(function(){
                video.safePlay();
              },1000);
            });

            document.addEventListener('visibilitychange', function(){
              if(document.visibilityState=='visible'){
                video.safePlay();
              }
            })

             video.addEventListener('seeking', seek);
             this.cleanupInterval = setInterval(function(){
               if (!sourceBuffer.updating && video.buffered.length > 0) {
                 if (video.currentTime - 5 > video.buffered.start(0)) {
                   sourceBuffer.remove(video.buffered.start(0), video.currentTime - 5);
                 }
              }
             },1000);
             checkBuffer(); //trigger the first packet
          };

          function appendSegment(chunk) {
            sourceBuffer.appendBuffer(chunk);
          };

          function checkBuffer(_) {
              //if anything in buffer, call appendSegment with the next item in the buffer
              if((buffer.length>0) && (!sourceBuffer.updating)){
                appendSegment(buffer.shift());
              }
            //console.log(video.currentTime, currentSegment, segmentDuration);
          };
          this.checkBuffer = checkBuffer;
          function seek(e) {
            log(e);
            if (mediaSource.readyState === 'open') {
              sourceBuffer.abort();
              log(mediaSource.readyState);
            } else {
              log('seek but not open?');
              log(mediaSource.readyState);
            }
          };

        },
        append: function(data) {
          maxQueueSize = this.latencyReducer ? 30:120;

          if(this.buffer.length>=maxQueueSize){
            this.buffer.shift();
          }
          this.buffer.push(data);
          this.checkBuffer();
        }

      });
    }());
  </script>
</dom-module>
