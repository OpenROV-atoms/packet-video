<link rel="import" href="../polymer/polymer.html">
<dom-module id="packet-video">
  <style>
    /* TODO(polyup): For speed, consider reworking these styles with .classes
                     and #ids rather than [attributes].
    */

    [hidden] {
      display: none !important;
    }
    /* make the video stretch to fill the screen in WebKit */

    :-webkit-full-screen {
      width: 100%;
      height: 100%;
    }
  </style>
  <style>
    :host {
      display: block;
      width: 320px;
      height: 200px
    }

    #video {
      width: 100%;
      height: 100%;
    }

    #stats {
      top: 0px;
      left: 0;
      position: absolute;
      margin: 10px;
      font-variant: bold;
      color: orange;
      font-size: 2vw;
      /*	visibility:hidden;        */
    }
  </style>
  <template>
    <div id="videocontainer" style="display:block; height:100%; width:100%; position:relative;" on-hover="">
      <img id="videomissing" src="{{novideoImageURL}}" hidden$="{{isHidden}}">
      <video id="video" ></video>
      <content></content>
      <div id='stats'>
        <div id='fps'><span>{{fps}}</span> decoded fps</div>
        <div id='bps'><span>{{bps}}</span> b/s</div>
        <div id='currentTime'><span>{{currentTime}}</span> (current time)</div>
        <div id='buffertime'><span>{{formatSeconds(buffertime)}}</span> (buffertime)</div>
        <div><span>{{formatSeconds(buffertimeStart)}}</span> (buffertime-start)</div>
        <div><span>{{formatSeconds(buffertimeEnd)}}</span> (buffertime-end)</div>

        <div id='gaptime'><span>{{formatSeconds(gaptime)}}</span> (gaptime)</div>
        <div id='queue'><span>{{queueSize}}</span> (queue size)</span>
        </div>
        <div><span>{{error}}</span> Video error?</div>
        <div><span>{{paused}}</span> Video paused?</div>
        <div><span>{{videoState}}</span> Video state</div>
        <div><span>{{droppedframes}}</span> dropped frames</div>
        <div><span>{{decodedframes}}</span> decoded frames</div>
        <div><span>{{stats.errors.video.code3}}</span> code3 video errors</div>
        <div><span>{{stats.errors.video.bufferDisassociation}}</span> buffer dissasociations</div>
        <div><span>{{stats.errors.video.totalfailure}}</span> totalfailure</div>
      </div>
    </div>
  </template>
  <script src="../visionmedia-debug/dist/debug.js"></script>
  <script>
    (function() {
      var log = debug('socket-video:unclassified');
      var log_setup = debug('socket-video:setup');
      var log_trace = debug('socket-video:trace');
      var log_healthCheck = debug('socket-video:healthCheck');
      Polymer({
        is: 'packet-video',
        properties: {
          latencyReducer: {
            type: Boolean,
            value: false
          },
          initialized: {
            type: Boolean,
            value: false,
            readOnly: true
          }
        },
        buffer: [],
        init: function(initFrame, callback) {
          var buffer=this.buffer;
          buffer.push(initFrame)
          var video = this.$.video;
          [
            'loadstart',
            'emptied',
            'canplaythrough',
            'ended',
            'ratechange',
            'progress',
            'stalled',
            'playing',
            'durationchange',
            'resize',
            'suspend',
            'loadedmetadata',
            'waiting',
            'timeupdate',
            'volumechange',
            'abort',
            'loadeddata',
            'seeking',
            'play',
            'error',
            'canplay',
            'seeked',
            'pause'
          ].forEach(function (ev) {
            video.addEventListener(ev, function () {
              console.log('video event:', ev);
            });
          });

          // ./mp4info frag_bunny.mp4 | grep Codec
          var mimeCodec = 'video/mp4; codecs="avc1.4d401e"';

          var mediaSource = null;
          if ('MediaSource' in window && MediaSource.isTypeSupported(mimeCodec)) {
            mediaSource = new MediaSource;
            [
              'sourceopen',
              'sourceended',
              'sourceclose',
              'loadedmetadata',
              'loadeddata',
              'canplay',
              'canplaythrough',
              'seeking',
              'ended',
              'loadstart',
              'playing',
              'waiting',
              'progress',
              'suspend',
              'stalled'
            ].forEach(function (ev) {
              mediaSource.addEventListener(ev, function () {
                console.log('mediaSource event:', ev);
              });
            });

             [
               'addsourcebuffer',
               'removesourcebuffer'
             ].forEach(function (ev) {
                mediaSource.sourceBuffers.addEventListener(ev, function () {
                 console.log('sourceBufferList event:', ev);
               });
             });

            var self=this;
            mediaSource.sourceBuffers.addEventListener('addsourcebuffer', function(){
              self._setInitialized(true);
              callback();
            })


            //console.log(mediaSource.readyState); // closed
            video.src = URL.createObjectURL(mediaSource);
            mediaSource.addEventListener('sourceopen', sourceOpen);
          } else {
            console.error('Unsupported MIME type or codec: ', mimeCodec);
          }

          var sourceBuffer = null;

          function sourceOpen(_) {
             sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);
             [
               'updatestart',
               'updateend',
               'update',
               'error',
               'abort'
             ].forEach(function (ev) {
               sourceBuffer.addEventListener(ev, function () {
                 //TODO: Move the event tracing to a debug library for runtime on/off
                 console.log('sourceBuffer event:', ev);
               });
             });
             if (sourceBuffer.mode){
                sourceBuffer.mode = 'sequence';
             }
             console.log('sourceBuffer mode:',sourceBuffer.mode);
             sourceBuffer.addEventListener('updateend',function(){
               checkBuffer;
             })
             checkBuffer();
             video.addEventListener('timeupdate', checkBuffer);
             video.addEventListener('canplay', function() {
                video.play();
             });
             video.addEventListener('loadedmetadata',function(){
               setTimeout(function(){
                 //video.currentTime+=.001;
                 video.play()
               },1000);
               //video.play(); //because canplay won't fire
             })
             video.addEventListener('seeking', seek);

          };

          function appendSegment(chunk) {
            sourceBuffer.appendBuffer(chunk);
            console.log('video current time:',video.currentTime);
          };

          function checkBuffer(_) {
              //if anything in buffer, call appendSegment with the next item in the buffer
              if((buffer.length>0) && (!sourceBuffer.updating)){
                appendSegment(buffer.shift());
              }
            //console.log(video.currentTime, currentSegment, segmentDuration);
          };
          this.checkBuffer = checkBuffer;
          function seek(e) {
            console.log(e);
            if (mediaSource.readyState === 'open') {
              sourceBuffer.abort();
              console.log(mediaSource.readyState);
            } else {
              console.log('seek but not open?');
              console.log(mediaSource.readyState);
            }
          };

        },
        append: function(data) {
          this.buffer.push(data);
          this.checkBuffer();
        }

      });
    }());
  </script>
</dom-module>
