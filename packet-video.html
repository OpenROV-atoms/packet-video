<link rel="import" href="../polymer/polymer.html">
<dom-module id="packet-video">
  <style>
    /* TODO(polyup): For speed, consider reworking these styles with .classes
                     and #ids rather than [attributes].
    */
    
    [hidden] {
      display: none !important;
    }
    /* make the video stretch to fill the screen in WebKit */
    
    :-webkit-full-screen {
      width: 100%;
      height: 100%;
    }
  </style>
  <style>
    :host {
      display: block;
      width: 320px;
      height: 200px
    }
    
    #video {
      width: 100%;
      height: 100%;
    }
    
    #stats {
      top: 5px;
      left: 5px;
      position: absolute;
      padding: 2px;
      margin: 10px;
      font-variant: bold;
      color: orange;
      font-size: 1.5vw;
    }
  </style>
  <template strip-whitespace>
    <div id="videocontainer" style="display:block; height:100%; width:100%; position:relative;" on-hover="">
      <video id="video" ></video>
      <content></content>
      <div id='stats' hidden$="{{!showStats}}">
        <div id='fps'><span>{{fps}}</span> decoded fps</div>
        <div id='bps'><span>{{bps}}</span> b/s</div>
        <div id='packets'><span>{{pps}}</span> p/s</div>
        <div id='currentTime'><span>{{currentTime}}</span> (current time)</div>
        <div id='buffertime'><span>{{formatSeconds(buffertime)}}</span> (buffertime)</div>
        <div><span>{{formatSeconds(buffertimeStart)}}</span> (buffertime-start)</div>
        <div><span>{{formatSeconds(buffertimeEnd)}}</span> (buffertime-end)</div>

        <div id='gaptime'><span>{{formatSeconds(gaptime)}}</span> (gaptime)</div>
        <div id='queue'><span>{{queueSize}}</span> (queue size)</span>
        </div>
        <div><span>{{error}}</span> Video error?</div>
        <div><span>{{paused}}</span> Video paused?</div>
        <div><span>{{videoState}}</span> Video state</div>
        <div><span>{{droppedframes}}</span> dropped frames</div>
        <div><span>{{decodedframes}}</span> decoded frames</div>
        <div><span>{{stats.errors.video.code3}}</span> code3 video errors</div>
        <div><span>{{stats.errors.video.bufferDisassociation}}</span> buffer dissasociations</div>
        <div><span>{{stats.errors.video.totalfailure}}</span> totalfailure</div>
      </div>
    </div>
  </template>
  <script src="../visionmedia-debug/dist/debug.js"></script>
  <script>
    (function() {
      var log = debug('socket-video:unclassified');
      var log_setup = debug('socket-video:setup');
      var log_trace = debug('socket-video:trace');
      var log_healthCheck = debug('socket-video:healthCheck');
      Polymer({
        is: 'packet-video',
        properties: {
          latencyReducer: {
            type: Boolean,
            value: true
          },
          initialized: {
            type: Boolean,
            value: false,
            readOnly: true
          },
          showStats: {
            type: Boolean,
            value: false
          }
        },
        getVideoElement: function() {
          return this.$.video;
        },
        stop: function() {
          this._setInitialized(false);
          this.shortCircuitAppend = true;
          this.$.video.pause();
          if (this.mediaSource) {
            this.mediaSource.endOfStream();
          }

        },
        ready: function() {
          var self = this;
          this.fps_count = 0;
          this.fps = 0;
          this.datapackets_count = 0;
          this.bytes_count = 0;
          this.bps = 0;
          this.buffertime = 0;
          this.buffertimeStart = 0;
          this.buffertimeEnd = 0;
          this.gaptime = 0;
          this.paused = true;
          this.error = false;
          this.currentTime = 0;
          this.droppedframes = 0;
          this.decodedframes = 0;
          this.pps = 0;
          this.pps_count = 0;
          this.stats = {
            errors: {
              video: {
                code3: 0,
                bufferDisassociation: 0,
                totalfailure: 0
              },
              mediaSource: 0,
              bufferSource: 0
            }
          };
          var video = this.$.video;
          if (this.latencyReducer) {
            video.playbackRate = 5; //burn through any buffer
            var latencyInterval = function() {
              var cooldown = 0; 
              if (!video.paused) {
                if (video.buffered.length > 0) {
                  var gaptime = video.seekable.end(0) - video.currentTime;
                 
                  if ((gaptime > 4) || (gaptime < -4)) {
                    log_trace('reducing latency by seeking +.001');
                    video.currentTime = video.seekable.end(0) - 0.001;
                    cooldown = 30000;
                  }
                  
                  if ((video.playbackRate == 1) && (gaptime>.1)) {
                    video.playbackRate = 5;
                    cooldown += 1000;
                    log_trace('setting playback = 5');
                  } else if (video.playbackRate == 5){
                    video.playbackRate = 1;
                    log_trace('setting playback = 1');                    
                  }                 
                }
                
                

              }
              setTimeout(latencyInterval, 500 + cooldown);
            };
            latencyInterval();
          }


          this.statsIntervalTimer = setInterval(function() {
            if (!self.initialized) {
              return;
            }
            var video = self.$.video;
            self.paused = video.paused;
            self.queueSize = self.buffer.length;
            self.error = video.error !== null;
            self.fps = (self.droppedframes + self.decodedframes) - self.fps_count;
            self.fps = self.fps; //per second
            self.bps = (self.bytes_count * 8).toLocaleString();
            self.fps_count = self.droppedframes + self.decodedframes;
            self.bytes_count = 0;
            self.pps = self.pps_count;
            self.pps_count = 0;
            self.currentTime = video.currentTime.toLocaleString();
            self.droppedframes = video.webkitDroppedFrameCount;
            self.decodedframes = video.webkitDecodedFrameCount || video.mozDecodedFrames;
            if (video.buffered.length > 0) {
              self.buffertime = video.buffered.end(0) - video.buffered.start(0);
              self.gaptime = video.buffered.end(0) - video.currentTime;
              self.buffertimeStart = video.buffered.start(0);
              self.buffertimeEnd = video.seekable.end(0);
            } //TODO: Health Check where we are playing but there is no video buffer

          }, 1000);

          this.formatSeconds = function(seconds) {
            return Number(seconds).toFixed(2) + ' seconds';
          };
        },
        buffer: [],
        initInProgress: false,
        init: function(initFrame, callback) {
          if (this.initInProgress) {
            return
          };
          this.initInProgress = true;
          var buffer = this.buffer;
          buffer.push(initFrame)
          var video = this.$.video;
          [
            'loadstart',
            'emptied',
            'canplaythrough',
            'ended',
            'ratechange',
            'progress',
            'stalled',
            'playing',
            'durationchange',
            'resize',
            'suspend',
            'loadedmetadata',
            'waiting',
            'timeupdate',
            'volumechange',
            'abort',
            'loadeddata',
            'seeking',
            'play',
            'error',
            'canplay',
            'seeked',
            'pause',
            'cuechange',
            'encrypted',
            'reset'
          ].forEach(function(ev) {
            video.addEventListener(ev, function() {
              log_trace('video event:', ev);
            });
          });

          // ./mp4info frag_bunny.mp4 | grep Codec
          var mimeCodec = 'video/mp4; codecs="avc1.4d401e"';

          var mediaSource = null;
          this.mediaSource = mediaSource;
          if ('MediaSource' in window && MediaSource.isTypeSupported(mimeCodec)) {
            mediaSource = new MediaSource;
            [
              'sourceopen',
              'sourceended',
              'sourceclose',
              'loadedmetadata',
              'loadeddata',
              'canplay',
              'canplaythrough',
              'seeking',
              'ended',
              'loadstart',
              'playing',
              'waiting',
              'progress',
              'suspend',
              'stalled'
            ].forEach(function(ev) {
              mediaSource.addEventListener(ev, function() {
                log_trace('mediaSource event:', ev);
              });
            });
            var videoRequiresHumanTouch = /Android/i.test(navigator.userAgent);
            var safePlay = function() {
              if (!video.paused) {
                return;
              }
              if (video.buffered.length == 0) {
                return;
              }
              if (videoRequiresHumanTouch) {
                videoRequiresHumanTouch = false;
                document.addEventListener("touchstart", function(e) {
                  video.play();
                  document.removeEventListener(e.type, arguments.callee);
                }, false);
              } else {
                video.play();
              }
            }
            video.safePlay = safePlay;

            video.addEventListener('suspend', function() {
              //on a mobile connection, this seems to get triggered
              setTimeout(function() {
                safePlay()
              }, 1000);
            });

            [
              'addsourcebuffer',
              'removesourcebuffer'
            ].forEach(function(ev) {
              mediaSource.sourceBuffers.addEventListener(ev, function() {
                log_trace('sourceBufferList event:', ev);
              });
            });

            var self = this;
            mediaSource.sourceBuffers.addEventListener('addsourcebuffer', function() {
              self._setInitialized(true);
              callback();
              self.initInProgress = false;
            })


            //console.log(mediaSource.readyState); // closed
            video.src = URL.createObjectURL(mediaSource);

            mediaSource.addEventListener('sourceopen', sourceOpen);
          } else {
            console.error('Unsupported MIME type or codec: ', mimeCodec);
            return;
          }



          var sourceBuffer = null;

          function sourceOpen(_) {
            sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);
            [
              'updatestart',
              'updateend',
              'update',
              'error',
              'abort'
            ].forEach(function(ev) {
              sourceBuffer.addEventListener(ev, function() {
                //TODO: Move the event tracing to a debug library for runtime on/off
                log_trace('sourceBuffer event:', ev);
              });
            });
            if (sourceBuffer.mode) {
              sourceBuffer.mode = 'sequence';
            }
            log_trace('sourceBuffer mode:', sourceBuffer.mode);
            sourceBuffer.addEventListener('updateend', function() {
              checkBuffer;
            })

            video.addEventListener('timeupdate', checkBuffer);

            video.addEventListener('canplay', function() {
              safePlay();
            });

            video.addEventListener('progress', function() {
              safePlay();
            });

            video.addEventListener('loadedmetadata', function() {
              setTimeout(function() {
                //video.currentTime+=.001;
                video.safePlay();
              }, 500);
              //video.play(); //because canplay won't fire
            });
            //http://code.tutsplus.com/tutorials/html5-audio-and-video-what-you-must-know--net-15545
            video.addEventListener('loadeddata', function() {
              setTimeout(function() {
                video.safePlay();
              }, 1000);
            });

            document.addEventListener('visibilitychange', function() {
              if (document.visibilityState == 'visible') {
                video.safePlay();
              }
            })

            video.addEventListener('seeking', seek);
            this.cleanupInterval = setInterval(function() {
              if (!sourceBuffer.updating && video.buffered.length > 0) {
                return;
                //This is where we can save resource by aggresively dumping played frames.
                //but the buffers numbers seem to assume a 30fps which makes them wrong otherwise
                //so it is a bit tricky to get right, so relying on built in flushing
                //instead.
                if (video.currentTime - 5 > video.buffered.start(0)) {
                  sourceBuffer.remove(video.buffered.start(0), video.currentTime - 5);
                }
              }
            }, 1000);
            checkBuffer(); //trigger the first packet
          };

          function appendSegment(chunk) {
            sourceBuffer.appendBuffer(chunk);
          };

          function checkBuffer(_) {
            //if anything in buffer, call appendSegment with the next item in the buffer
            if ((buffer.length > 0) && (!sourceBuffer.updating)) {
              appendSegment(buffer.shift());
              // appendSegment(Uint8Array.from(buffer));
              // buffer.length=0;
            }
          };
          this.checkBuffer = checkBuffer;

          function seek(e) {
            log(e);
            if (mediaSource.readyState === 'open') {
              sourceBuffer.abort();
              log(mediaSource.readyState);
            } else {
              log('seek but not open?');
              log(mediaSource.readyState);
            }
          };

          function detect_detachedBuffer() {
            if ((video.buffered.length == 0) && (!video.paused)) {
              log_healthCheck('detached buffer detected');
              //This only appears to happen with streams that have more than just I frames.
              return true;
            }
            return false;
          }

          function recover_detachedBuffer() {
            //TODO: Recover from deteached buffer
            //            var original_src = video.src;
            video.pause();
            //            video.src = original_src;

          }

          this.healthCheckTimer = setInterval(function() {
            if (detect_detachedBuffer()) {
              recover_detachedBuffer();
            }
          }, 1000 / 15);

        },
        append: function(data) {
          if (this.shortCircuitAppend) {
            return;
          }
          if (this.lastcheck === undefined) {
            this.lastcheck = 0;
          }
          maxQueueSize = this.latencyReducer ? 120 : 600;
          if (this.lastcheck == data.length) {
            //return;
          }
          this.lastcheck = data.length;
          this.bytes_count += data.length;
          this.pps_count++;
          if (this.buffer.length >= maxQueueSize) {
            this.buffer.shift();
          }
          this.buffer.push(data);
          this.checkBuffer();
        },
        detached: function() {
          log('detached fired');
          this.stop();
        }

      });
    }());
  </script>
</dom-module>