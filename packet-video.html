<link rel="import" href="../polymer/polymer.html">
<dom-module id="packet-video">
  <style>
    /* TODO(polyup): For speed, consider reworking these styles with .classes
                     and #ids rather than [attributes].
    */

    [hidden] {
      display: none !important;
    }
    /* make the video stretch to fill the screen in WebKit */

    :-webkit-full-screen {
      width: 100%;
      height: 100%;
    }
  </style>
  <style>
    :host {
      display: block;
      width: 320px;
      height: 200px
    }

    #video {
      width: 100%;
      height: 100%;
    }

    #stats {
      top: 0px;
      left: 0;
      position: absolute;
      margin: 10px;
      font-variant: bold;
      color: orange;
      font-size: 2vw;
      visibility:hidden;
    }
  </style>
  <template>
    <div id="videocontainer" style="display:block; height:100%; width:100%; position:relative;" on-hover="">
      <img id="videomissing" src="{{novideoImageURL}}" hidden$="{{isHidden}}">
      <video id="video" ></video>
      <content></content>
      <div id='stats'>
        <div id='fps'><span>{{fps}}</span> decoded fps</div>
        <div id='bps'><span>{{bps}}</span> b/s</div>
        <div id='currentTime'><span>{{currentTime}}</span> (current time)</div>
        <div id='buffertime'><span>{{formatSeconds(buffertime)}}</span> (buffertime)</div>
        <div><span>{{formatSeconds(buffertimeStart)}}</span> (buffertime-start)</div>
        <div><span>{{formatSeconds(buffertimeEnd)}}</span> (buffertime-end)</div>

        <div id='gaptime'><span>{{formatSeconds(gaptime)}}</span> (gaptime)</div>
        <div id='queue'><span>{{queueSize}}</span> (queue size)</span>
        </div>
        <div><span>{{error}}</span> Video error?</div>
        <div><span>{{paused}}</span> Video paused?</div>
        <div><span>{{videoState}}</span> Video state</div>
        <div><span>{{droppedframes}}</span> dropped frames</div>
        <div><span>{{decodedframes}}</span> decoded frames</div>
        <div><span>{{stats.errors.video.code3}}</span> code3 video errors</div>
        <div><span>{{stats.errors.video.bufferDisassociation}}</span> buffer dissasociations</div>
        <div><span>{{stats.errors.video.totalfailure}}</span> totalfailure</div>
      </div>
    </div>
  </template>
  <script src="../visionmedia-debug/dist/debug.js"></script>
  <script>
    (function() {
      var log = debug('socket-video:unclassified');
      var log_setup = debug('socket-video:setup');
      var log_trace = debug('socket-video:trace');
      var log_healthCheck = debug('socket-video:healthCheck');
      Polymer({
        is: 'packet-video',
        properties: {
          latencyReducer: {
            type: Boolean,
            value: false
          },
          initialized: {
            type: Boolean,
            value: false,
            readOnly: true
          }
        },
        buffer: [],
        initInProgress: false,
        init: function(initFrame, callback) {
          if (this.initInProgress) {return};
          this.initInProgress=true;
          var buffer=this.buffer;
          buffer.push(initFrame)
          var video = this.$.video;
          [
            'loadstart',
            'emptied',
            'canplaythrough',
            'ended',
            'ratechange',
            'progress',
            'stalled',
            'playing',
            'durationchange',
            'resize',
            'suspend',
            'loadedmetadata',
            'waiting',
            'timeupdate',
            'volumechange',
            'abort',
            'loadeddata',
            'seeking',
            'play',
            'error',
            'canplay',
            'seeked',
            'pause'
          ].forEach(function (ev) {
            video.addEventListener(ev, function () {
              log_trace('video event:', ev);
            });
          });

          // ./mp4info frag_bunny.mp4 | grep Codec
          var mimeCodec = 'video/mp4; codecs="avc1.4d401e"';

          var mediaSource = null;
          if ('MediaSource' in window && MediaSource.isTypeSupported(mimeCodec)) {
            mediaSource = new MediaSource;
            [
              'sourceopen',
              'sourceended',
              'sourceclose',
              'loadedmetadata',
              'loadeddata',
              'canplay',
              'canplaythrough',
              'seeking',
              'ended',
              'loadstart',
              'playing',
              'waiting',
              'progress',
              'suspend',
              'stalled'
            ].forEach(function (ev) {
              mediaSource.addEventListener(ev, function () {
                log_trace('mediaSource event:', ev);
              });
            });

             [
               'addsourcebuffer',
               'removesourcebuffer'
             ].forEach(function (ev) {
                mediaSource.sourceBuffers.addEventListener(ev, function () {
                 log_trace('sourceBufferList event:', ev);
               });
             });

            var self=this;
            mediaSource.sourceBuffers.addEventListener('addsourcebuffer', function(){
              self._setInitialized(true);
              callback();
              self.initInProgress=false;
            })


            //console.log(mediaSource.readyState); // closed
            video.src = URL.createObjectURL(mediaSource);
            mediaSource.addEventListener('sourceopen', sourceOpen);
          } else {
            console.error('Unsupported MIME type or codec: ', mimeCodec);
          }

          var sourceBuffer = null;

          function sourceOpen(_) {
             sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);
             [
               'updatestart',
               'updateend',
               'update',
               'error',
               'abort'
             ].forEach(function (ev) {
               sourceBuffer.addEventListener(ev, function () {
                 //TODO: Move the event tracing to a debug library for runtime on/off
                 log_trace('sourceBuffer event:', ev);
               });
             });
             if (sourceBuffer.mode){
                sourceBuffer.mode = 'sequence';
             }
             log_trace('sourceBuffer mode:',sourceBuffer.mode);
             sourceBuffer.addEventListener('updateend',function(){
               checkBuffer;
             })
             checkBuffer();
             video.addEventListener('timeupdate', checkBuffer);
             var safePlay = function(){
               if (!video.pause){
                 return;
               }
               if (/Android/i.test(navigator.userAgent)){
                 document.addEventListener("touchstart", function(e){
                    video.play();
                    document.removeEventListener(e.type, arguments.callee);
                  }, false);
               } else {
                 video.play();
               }
             }
             video.addEventListener('canplay', function() {
                safePlay();
             });
             video.addEventListener('loadedmetadata',function(){
               setTimeout(function(){
                 //video.currentTime+=.001;
                 safePlay()
               },500);
               //video.play(); //because canplay won't fire
             });
            //http://code.tutsplus.com/tutorials/html5-audio-and-video-what-you-must-know--net-15545
            video.addEventListener('loadeddata',function(){
              setTimeout(function(){
                safePlay()
              },1000);
            });

             video.addEventListener('seeking', seek);
             this.cleanupInterval = setInterval(function(){
               if (!sourceBuffer.updating && video.buffered.length > 0) {
                 if (video.currentTime - 5 > video.buffered.start(0)) {
                   sourceBuffer.remove(video.buffered.start(0), video.currentTime - 5);
                 }
              }
             },1000);
          };

          function appendSegment(chunk) {
            sourceBuffer.appendBuffer(chunk);
          };

          function checkBuffer(_) {
              //if anything in buffer, call appendSegment with the next item in the buffer
              if((buffer.length>0) && (!sourceBuffer.updating)){
                appendSegment(buffer.shift());
              }
            //console.log(video.currentTime, currentSegment, segmentDuration);
          };
          this.checkBuffer = checkBuffer;
          function seek(e) {
            log(e);
            if (mediaSource.readyState === 'open') {
              sourceBuffer.abort();
              log(mediaSource.readyState);
            } else {
              log('seek but not open?');
              log(mediaSource.readyState);
            }
          };

        },
        append: function(data) {
          if(this.buffer.length>=20){
            this.buffer.shift();
          }
          this.buffer.push(data);
          this.checkBuffer();
        }

      });
    }());
  </script>
</dom-module>
